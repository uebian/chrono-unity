// =============================================================================
// PROJECT CHRONO - http://projectchrono.org
//
// Copyright (c) 2024 projectchrono.org
// All rights reserved.
//
// Authors: Josh Diyn
// =============================================================================

#pragma kernel CSMain

struct ShapeInfo
{
    float3 shapePos;
    int _pad0;           // Padding for 16-byte alignment
    float4 shapeRot;
    int bodyIndex;
    int _pad1;
    int _pad2;
    int _pad3;
};

// Body data: position + rotation (32 bytes aligned)
struct BodyData
{
    float3 pos;
    int _pad0;           // Padding for 16-byte alignment
    float4 rot;
};

// Buffers
StructuredBuffer<float3> vertices;
StructuredBuffer<int> vertexShapeIndices;
StructuredBuffer<ShapeInfo> shapeInfos;
StructuredBuffer<BodyData> bodyData;

// Output
RWStructuredBuffer<float3> transformedVertices;

// Constants
cbuffer GlobalParams : register(b0)
{
    int vertexCount;
    int shapeCount;
    int bodyCount;
}

// -------------------------------------------------
// Helper: rotate vector v by quaternion q
// q = (x, y, z, w)
// -------------------------------------------------
float3 RotateByQuaternion(float3 v, float4 q)
{
    // grab quaternion rotation
    float3 qxyz = q.xyz;
    float qw = q.w;
    
    // u = 2 * (q.xyz x v)
    float3 u = 2.0f * cross(qxyz, v);
    // v + qw * u + (q.xyz x u)
    return v + qw * u + cross(qxyz, u);
}

[numthreads(256, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if (i >= vertexCount)
        return;

    int shapeIdx = vertexShapeIndices[i];
    if (shapeIdx < 0 || shapeIdx >= shapeCount)
        return;

    ShapeInfo sInfo = shapeInfos[shapeIdx];
    if (sInfo.bodyIndex < 0 || sInfo.bodyIndex >= bodyCount)
        return;

    BodyData bd = bodyData[sInfo.bodyIndex];

    // local vertex position
    float3 localPos = vertices[i];
    // transform by shape local rotation + position
    float3 shapeP = RotateByQuaternion(localPos, sInfo.shapeRot) + sInfo.shapePos;
    // transform by the body's rotation + position
    float3 worldPos = RotateByQuaternion(shapeP, bd.rot) + bd.pos;
    transformedVertices[i] = worldPos;
}
